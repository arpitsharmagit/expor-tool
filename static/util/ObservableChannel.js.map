{"version":3,"sources":["lib/util/ObservableChannel.js"],"names":[],"mappings":"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","file":"lib/util/ObservableChannel.js","sourcesContent":["'use babel';\r\n'use strict';\r\n// ipc event communication\r\n// promises based\r\n// want event name and id of request (incrementing)\r\n// namespaced events would be pretty cool, may be able to use that for rev bit as well\r\n// just make async responses have incremented ID as event name?\r\n\r\n// this class allows for asyncronous message passing using promises\r\n// it binds with any eventEmitter-type objects that subscribe to it\r\n\r\n// TODO you never need more than one other emmitter.\r\n// TODO just have config bind to a single observable\r\n// TODO makes life a lot easier.  and just about remote procedure calls then\r\n\r\nvar Q = require('q'),\r\n    _ = require('lodash'),\r\n    Observable = require('./Observable');\r\n\r\nconst DEFAULT_TIMEOUT = 60 * 1000 * 15; // 15 min\r\n\r\nclass ObservableChannel extends Observable {\r\n  constructor (cfg = {}) {\r\n    super(cfg);\r\n    this.timeout = cfg.timeout || DEFAULT_TIMEOUT;\r\n    this.channel = cfg.channel || new Observable();\r\n  }\r\n\r\n  submit (eventName, ...args) {\r\n    var messageId = _.uniqueId(),\r\n        resolveEventName = `${eventName}:${messageId}:resolve`,\r\n        rejectEventName = `${eventName}:${messageId}:reject`,\r\n        deferred = Q.defer();\r\n\r\n    this.channel.on(resolveEventName, deferred.resolve);\r\n    this.channel.on(rejectEventName, deferred.reject);\r\n\r\n    let promise = deferred.promise;\r\n\r\n    if (this.timeout) {\r\n      promise = promise.timeout(this.timeout);\r\n    }\r\n\r\n    promise = promise.finally( (...args) => {\r\n      this.channel.off(resolveEventName, deferred.resolve);\r\n      this.channel.off(rejectEventName, deferred.reject);\r\n      return;\r\n    });\r\n\r\n    // ensure asyncronous calls\r\n    setTimeout( () => {\r\n      this.emit.apply(this, ['submit', eventName, messageId].concat(args));\r\n      let emitfn = this.channel.send || this.channel.emit;\r\n      emitfn.apply(this.channel, [eventName, messageId].concat(args));\r\n    }, 0);\r\n\r\n    return promise;\r\n  }\r\n\r\n  // any time an event is received then run callback\r\n  // callback should return a promise\r\n  route (eventName, callback = _.noop) {\r\n    this.channel.on(eventName, (messageId, ...args) => {\r\n      var resolveEventName = `${eventName}:${messageId}:resolve`,\r\n          rejectEventName = `${eventName}:${messageId}:reject`,\r\n          promise;\r\n\r\n      try {\r\n        promise = Q(callback.apply(this.context, args));\r\n      } catch (err) {\r\n        promise = Q.reject(err);\r\n      }\r\n      if (this.timeout) {\r\n        promise = promise.timeout(this.timeout);\r\n      }\r\n\r\n      let emitfn = this.channel.send || this.channel.emit;\r\n      promise\r\n        .then(emitfn.bind(this.channel, resolveEventName))\r\n        .catch(emitfn.bind(this.channel, rejectEventName))\r\n        .done();\r\n\r\n      setTimeout( () => {\r\n        this.emit('route', eventName, promise.inspect());\r\n      }, 0);\r\n\r\n    });\r\n  }\r\n  createRouteStream (route, eventType, content) {\r\n    var self = this;\r\n    // commandstart\r\n    // channel\r\n    // commandfinished\r\n    // respond with route event:id\r\n    Q.async(function* (iterable) {\r\n      var commandStart = self.submit.call(self, 'stream:start'),\r\n          errorDetected = false;\r\n      yield commandStart;\r\n\r\n      let streamId = commandStart.inspect().value,\r\n          eventBase = `stream:${streamId}`,\r\n          errorEvent = eventBase + ':error',\r\n          dataEvent = eventBase + ':data';\r\n\r\n      let onError = (err) => {\r\n        console.error('failure on stream', err);\r\n        errorDetected = err;\r\n      };\r\n\r\n      self.channel.one(errorEvent, onError);\r\n\r\n      try {\r\n        for (let item of iterable) {\r\n            let dataReceived = self.submit.call(self, dataEvent, item);\r\n            yield dataReceived;\r\n\r\n            // wait one tick, should allow onError to detect errors\r\n            //let hasError = yield Q.delay(0);\r\n            //if (errorDetected) { throw errorDetected; }\r\n        }\r\n      } catch (err) {\r\n        console.error('failure on iterating', err);\r\n        errorDetected = err;\r\n      } finally {\r\n        if (errorDetected) {\r\n        }\r\n\r\n        let commandFinish = self.submit.call(self, 'stream:end');\r\n        yield commandFinish;\r\n\r\n      }\r\n\r\n    });\r\n  }\r\n  subscribe (routeId, callback = _.noop) {\r\n    this.channel.on('routeMessage' );\r\n  }\r\n  unsubscribe (routeId) {\r\n\r\n  }\r\n  broadcast (...args) {\r\n    this.emit.apply(this, args);\r\n    try {\r\n      let emitfn = this.channel.send || this.channel.emit;\r\n      emitfn.apply(this.channel, args);\r\n    } catch (err) {\r\n      console.warn('error on observerchannel channel emit', args, err);\r\n    }\r\n  }\r\n  listenTo (...args) {\r\n    this.channel.on.apply(this.channel, args);\r\n  }\r\n  listenToOnce (...args) {\r\n    this.channel.one.apply(this.channel, args);\r\n  }\r\n  stopListening (...args) {\r\n    this.channel.off.apply(this.channel, args);\r\n  }\r\n}\r\n\r\nmodule.exports = ObservableChannel;\r\n\r\n/*\r\n  Observable = require('./Observable')\r\n  ObservableChannel = require('./ObservableChannel');\r\n*/\r\n"]}